<!DOCTYPE html>
<html lang="en">

<head>
    <title>Django в мире микросервисов и Kafka</title>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <!--<link id="favicon" rel="shortcut icon" type="image/png" href="data:image/png;base64,">-->

    <link rel="stylesheet" href="../vendor/shower/styles/purple-16x9.css">
    <link rel="stylesheet" href="../vendor/shower/vendors/highlight/styles/github.css">
    <style>
    
    .cards > div {
        width: 33.33%;
        float: left;
        line-height: 1.6;
    }
    
    .tags-baloons {
        margin-top: 20px;
        text-align: center;
        font-size: 40px;
    }
    .tags-baloons .label {
        border-radius: 15px 20px;
        margin-bottom: 15px;
    }
    .slide-footer.author,
    .slide-footer.notable {
        font-size: 20px;
        padding: 20px 40px;
    }
    .slide footer {
        color: black;
        padding: 10px;
    }
    h1,h2,h3,h4,h5,h6,h7 {
         font-family: PT Sans Narrow;
    }
    .slide {
        /* font-size: 32px; /**/
        
        /* line-height: 1.6; /***/
    }
    .slide code {
        /* background: none; */
    }
    .slide .strike:after {
        background-color: red;
    }
    .slide.red .strike:after {
        background-color: black;
        height: 9px;
    }

    .slide:before {
        content: "";
        display: block;
        position: absolute;
        bottom: 10px;
        left: 10px;
        width: 200px;
        height: 30px;
        background-size: fit;
        background-image: url("pictures/logos/itechart-black.svg");
        background-postion: bottom right;
        background-repeat: no-repeat;
    }

    .slide.black:before,
    .slide.red-dark:before,
    .slide.red:before {
        filter: invert(1);
    }
    
    .slide:after {
        background: transparent url('pictures/system/slide-number-bg.svg') center center no-repeat;
        background-size: 70px;
        border-radius: 0;
        width: 70px;
        font-size: 0.95em;
    }
    .slide.black:after {
        background-color: transparent;
        color: darkgray;
        filter: invert(1) sepia(1); 
    }
    .slide.red-dark:after,
    .slide.red:after {
        background-color: transparent;
        color:darkgoldenrod;
        filter: grayscale(1) invert(1) contrast(3);
    }
    

    .slide.red-dark {
        background-color: #680000
    }
    .slide.red-dark:after {
        color: #680000
    }

    .slide.no-logo:before {
        display: none;
    }

    .slide h2, /* disable border on all slides */
    .slide h2.no-border, .slide h2.no-line {
        border-bottom: none;
    }
    .cards > div {
        width: 33.33%;
        float: left;
        line-height: 1.6;
    }

    .tags-baloons {
        margin-top: 20px;
        text-align: center;
        font-size: 40px;
    }
    .tags-baloons .label {
        border-radius: 15px 20px;
        margin-bottom: 15px;
    }
    .slide-footer.author,
    .slide-footer.notable {
        font-size: 20px;
        padding: 20px 40px;
    }
    .slide footer {
        color: black;
        padding: 10px;
    }

    .slide-footer small {
        font-size: 12px;
    }

    .lighty {
            color: rgba(0,0,0, 0.45);
    }

    .slide.black  .lighty,
    .slide.red .lighty {
        color: rgba(255,255,255, 0.45);
    }

    .huge {
        font-size: 42px;
    }
    .padding {
        padding-left: 150px;
        padding-top: 50px;
    }
    .padding-sm {
        padding-left: 150px;
        padding-top: 25px;
    }
    </style>
</head>

<body class="shower list">
    <header class="caption">
        <!-- <h1>Bring Django to the microservices world using Kafka</h1> -->
        <h1>Django в мире микросервисов и Kafka</h1>

        <p>
            <a href="https://github.com/shurph/talks">Mikalai Saskavets</a>
        </p>
    </header>



    <section class="slide clear no-logo">
        <img src="https://avatars.mds.yandex.net/get-zen_doc/1841592/pub_5ce45b5ecc128400b01863ef_5ce46a52856cd5031a70bfd6/scale_2400" 
            class="place left center" 
            style="width: 25%; margin-left: 150px;">
        <img src="https://upload.wikimedia.org/wikipedia/commons/7/7a/Kafka5jahre.jpg" 
            class="place right center" 
            style="width: 22.5%; margin-right:150px;">
        <img src="https://images.eksmo.ru/images/kafka_2.jpg" class="cover w">
        <h2 class="shout" style="font-size: 42px; white-space: nowrap; padding: 5px 0 10px 0; color: black; background: rgba(255,255,255,0.75)">
            Django в мире микросервисов и Kafka
        </h2>
        <span class="slide-footer" style="font-size: 20px; padding: 10px 20px;  color: black; background: rgba(255,255,255,0.75)">
            Mikalai Saskavets
            <br>
            <small>@ iTechArt-Group</small>
            
        </span>
        <div  class="place top left" style="margin: 20px 0 0 40px; padding: 0 20px; font-size: 20px; color: black; background: rgba(255,255,255,0.75)">
            iTechMeetup Grodno #5
        </div>
        
        <footer>
        </footer>
    </section>
    
    
    
    <section class="slide half-red  clear">
        <div style="width: 40%; padding-right: 0">
            <h3 style="
                    font-size: 1.8rem; line-height: 1.33;   margin-bottom: 0rem; ;

                ">Mikalai Saskavets</h3>
                <span style="line-height: 1.2; font-size: 0.85em;">
                    I'm a:
                    <br>&mdash; Full Stack Web Developer
                    <br>&mdash; DevOps Enthusiast
                    <br>
                    <br>
                </span>
            <br>
            <img src="../kafka-mogilev/pictures/mikalai-photo.png" alt="" width="75%" >
        
        </div>
        <div>
            I'm with:<br>
            • iTechArt<br>
            • PyCon Belarus Program Committee<br>
            • Minsk Python Meetup Program Committee<br>
        </div>
        <footer></footer>
    </section>





    <section class="slide">
        <h2 class="shout">the App</h2>
    </section>



    <section class="slide clear black">
        <img src="../kafka-mogilev/pictures/monolith_by_reneaigner.jpg" alt="" class="cover h" style="height: 110%; max-height: 110%">
        <span class="slide-footer" style="font-size: 12px;" >
            art by <a href="https://www.deviantart.com/reneaigner/art/Monolith-283096035">René Aigner</a> 
        </span>
        
        
        <footer>

И так, на руках у нас был монолит. Руковтворное чудо.
Всем хорош!...


        </footer>
    </section>
    
    
    
    
    <section class="slide clear ">
        <img src="../kafka-mogilev/pictures/monolith_by_reneaigner_edited.jpg" alt="" class="cover h" style="height: 110%; max-height: 110%">
        <h3>Monolithic MVP</h3>
<ul>
<li>Scalability issues</li>
<li>Readability issues</li>
<li>Maintainability issues</li>
<li>Security issues</li>
</ul>
        <footer>
Кроме того, что совершенно не держал нагрузку, код был  очень запутан и были  вопросы по безопасности...

Настоящий MVP, одним словом...


И если для тестовых пятиста пользователей и пары видов спорта это было нормально, то для более широкой публики это уже было неприемлемо. Да и видов спорта должно было стать больше к моменту выхода в продекшен.

Да, наше приложение было про спорт и нам приходилось работать с большим количеством спортивных данных, приходящих из внешних источников. В том числе и в режиме реального времени.

И нужно было как-то с этим справляться.
        </footer>
    
    </section>
    <!--
    <section class="slide clear black">
        <img src="../kafka-mogilev/pictures/monolith_nature.jpg" alt="" class="cover w">
        <span class="slide-footer" style="font-size: 12px;" >
            photo by <a href="https://www.flickr.com/photos/zest-pk/924783502">Zest-pk</a> 
        </span>
    </section><!---->
    
    
    <section class="slide clear black">
        <img src="../kafka-mogilev/pictures/microservices-microservices-everywhere.jpeg" alt="" class="cover"> 
        
        
        <footer>
И серебрянной пулей мы выбрали микросервисы.
Конечно, все мы прекрасно знаем, что микросервисы решают все наши проблемы!

        </footer>         
    </section>
    
    

    <section class="slide ">
        <img src="../kafka-mogilev/pictures/mono-to-micro-3-more-real.png" alt="" class="cover w">
        <!-- image from: https://medium.com/salesloft-engineering/monolith-to-microservice-without-downtime-a-production-story-652c9b82f03e -->
        <div class="slide-footer" style="bottom: 0.5rem; font-size:10px">
        Fig. from <a href="https://medium.com/salesloft-engineering/monolith-to-microservice-without-downtime-a-production-story-652c9b82f03e">Steve Bussey's article</a>
        </div>
        
        <footer>

Но действительно ли это так?
Вот у нас был монолит. Мы разбросали его куски по облачкам микросервисов и наладили связи между ними. Общаются у нас микросервисы, допустим, через REST API.
        </footer>
    </section>
    

    <section class="slide "> <!-- EDITED 1 -->
        <img src="../kafka-mogilev/pictures/mono-to-micro-4-even-more-real.png" alt="" class="cover w">
        <!-- image from: https://medium.com/salesloft-engineering/monolith-to-microservice-without-downtime-a-production-story-652c9b82f03e -->
        
        
        <footer>

А наше приложение начало расти, микросервисов стало больше.

        </footer>
    </section>
    
    <section class="slide "> <!-- EDITED 2 -->
        <img src="../kafka-mogilev/pictures/mono-to-micro-5-more-relations.png" alt="" class="cover w">
        <!-- image from: https://medium.com/salesloft-engineering/monolith-to-microservice-without-downtime-a-production-story-652c9b82f03e -->
        
        
        <footer>
Связей между сервисами начинает становиться больше


        </footer>
    </section>
    
    <section class="slide "> <!-- EDITED 3 -->
        <img src="../kafka-mogilev/pictures/mono-to-micro-6-a-lot-of-relations.png" alt="" class="cover w">
        <!-- image from: https://medium.com/salesloft-engineering/monolith-to-microservice-without-downtime-a-production-story-652c9b82f03e -->
        
        
        <footer>
И еще больше!
Пока у нас не начинает возникать мысль, что каждый сервис общается с каждым, и может быть не по одному разу. Но это не точно.


        </footer>
    </section>
    
    <style>
      .lite {
        color: white!important;
        border: none!important;
      }
      .shadowed {
        text-shadow: #4A205A 5px 5px 5px
      }
      .pinky-bg {
        background: rgb(134,113,213);
        background: linear-gradient(
            90deg,
            rgba(134,113,213,1) 0%,
            rgba(146,81,176,1) 40%,
            rgba(232,137,232,1) 100%
        );
      }
    </style>
    <section class="slide">
        <h2 class="lite shadowed">Microservices: Coupling and Cohesion?</h2>
        <img src="../kafka-mogilev/pictures/distributed-monolith.png" alt="" class="cover h">
        <!-- image from: https://medium.com/salesloft-engineering/monolith-to-microservice-without-downtime-a-production-story-652c9b82f03e -->
        
        
        <footer>
И так, у нас рано или поздно может возникнуть понимание, что сервисы-то у нас чересчур друг от друго зависимы, высокая связность у нас в нашей микросервисной архитектуре...

        </footer>
      
    </section>


    <section class="slide"> <!-- EDITED 4 -->
        <h2 class="lite shadowed">Distributed Monolith?</h2>
        <img src="../kafka-mogilev/pictures/distributed-monolith.png" alt="" class="cover h">
        <!-- image from: https://medium.com/salesloft-engineering/monolith-to-microservice-without-downtime-a-production-story-652c9b82f03e -->
        
        
        <footer>
А микросервисное ли у нас вообще приложение, или какой-то, простите, распределенный монолит?!
Ну... это все конечно слова... теория!

        </footer>
    </section>

    <style>
       .cover.w.hotfix {
           margin-top: 5%; width: 90%
       }
    </style>
    <section class="slide">
        <h2>Microservices: Synchronous Communication</h2>
        <center style="margin-top: -25px">
            ( REST API )
        </center>
        <img src="../kafka-mogilev/pictures/1-few.svg" alt="" class="cover w hotfix"> 
        
        
        <footer>
Давайте рассмотрим практический случай.
Вот у нас запрос от пользователя. Он затрагивает три микросервиса.
Запросы  идут последовательно,... павольна! не быстро, то есть.

        </footer> 
    </section>
    
    
    
    <section class="slide">
        <h2>Microservices: Synchronous Communication</h2>
        <center style="margin-top: -25px">
            ( REST API )
        </center>
        <img src="../kafka-mogilev/pictures/1-many.svg" alt="" class="cover w hotfix">  
        
        
        <footer>
А еще у нас-то может оказаться, напомню, распределенный монолит.
И запрос от пользователя может пройтись по нашим микросервисам 5, 6, 7 раз!
И пользователь будет ждать.
А не хотелось бы.

К счастью, в нашем случае, удача была на нашей стороне и все вот эти опросы других четырех сервисов никак не влияли на конечный результат для пользователя. Они лишь запускали какие-то изменения в системе, нужные самой системе, а не пользователю вот прямо сейчас.

        </footer>
    </section>




    <!--
    <section class="slide">
        <h2>Так ли это медленно?</h2>
<pre class="plain"><code>0.3 ns      1 s          1 CPU cycle 
...
120 ns      6 min        Main memory access
50-150 μs   2-6 days     Solid-state disk I/O    
1-10 ms     1-12 months  Rotational disk I/O 
<span style="color:red">10-50 ms    1-5 years    Network request</span>
40 ms       4 years      Internet: SF to NYC</code>
</pre>
        <span class="slide-footer">
            by Jeff Atwood,

            <a href="https://blog.codinghorror.com/the-infinite-space-between-words/">
                 The Infinite Space Between Words
</a>
        </span>    
    </section><!-- -->

    <section class="slide">
        <h2>Microservices: Async Communication (Celery)</h2>
        <img src="../kafka-mogilev/pictures/2-celery-rabbit.svg" alt="" class="cover w hotfix">
        
        
        <footer>
Ну и конечно же, первое что приходит на ум питонисту, когда у него на руках джанго и намечается какое-то асинхронное поведение.
Celery!
Вынесем те участки кода, которые взаимодействуют с другими микросервисами, в Celery таски! Делов-то!

Однако, здесь возникают моментики...
Ранее при каких-то проблемах в цепочке запросов мы могли просто сказать пользователю «Моряк, ты слишком долго плавал! Попробуй еще раз!». Не самый элегантный подход, но простой, как грабли.
А теперь нам нужно думать. Что делать, если запрашиваемый сервис сейчас недоступен, например? Забить на эту celery-таску? Или закинуть ее еще раз в очередь, вдруг во второй раз она выполнится успешно? Или в третий?
Тоже вполне себе рабочий подход.
Но почему вообще первый микросервис должен заботиться о всех этих вещах? Почему он вообще должен знать о других сервисах, если для работы с пользователем ему другие сервисы не нужны-то напрямую?

        </footer>  
    </section>


    <section class="slide">
        <h2>Microservices: Async Communication (Celery)</h2>
        <img src="../kafka-mogilev/pictures/2-celery-rabbit.svg" alt="" class="cover w hotfix" style="opacity: 0.35"> 
        <h3 class="shout">

            <img src="../kafka-mogilev/pictures/emoji/thinking-face.svg">
            <style>
            .stroke-big-white {
                text-shadow: white 5px 5px 0px,
                             white -5px 5px 0px,
                             white 5px -5px 0px,
                             white -5px -5px 0px,

                             white 8px 8px 0px,
                             white -8px 8px 0px,
                             white 8px -8px 0px,
                             white -8px -8px 0px;
            }
            </style>
            <span class="stroke-big-white">
                <br>
                shall we use
                <br>
                Kafka here???
            </span>
        </h3> 
        
        
        <footer>
И тут возникает мысль.
А вдруг нам здесь может как-то помочь Kafka?

        </footer>
    </section>



  
    <section class="slide">
        <h2 class="shout">
            What is
            <span style="display: inline-block;  height: 20px;">
                <img src="../kafka-mogilev/pictures/logos/kafka-logo-black.png" height="90px" style="
                    position: relative;
                    float: left;
                    margin-top: -45px;
                    opacity: 0.75;">
            </span>
            Kafka?
        </h2> 
        
        
        <footer>
Но давайте сначала чуть-чуть посмотрим, что такое кафка.


        </footer>
    </section>

    
    <section class="slide">
        <h2>
            What is
            <span style="display: inline-block;  height: 20px;">
                <img src="../kafka-mogilev/pictures/logos/kafka-logo-black.png" height="90px" style="
                    position: relative;
                    float: left;
                    margin-top: -45px;
                    opacity: 0.75;">
            </span>
            Kafka?
        </h2>
         
         
        <div class="tags-baloons">
            <span class="label">
                Distributed Streaming Platform 
            </span>
        </div>
        <span style="font-size: 32px">Initially conceived as a messaging queue... Now Apache Kafka is a full-fledged distributed event streaming platform capable of handling <mark>trillions</mark> of events a day.</span>

        <sup><a href="https://www.confluent.io/what-is-apache-kafka/" style="background: none">[↪]</a></sup>
        <!--
        Apache Kafka — это распределенная система обмена сообщениями с высокой пропускной способностью, которую можно использовать для упрощения масштабируемого сбора данных. <sup><a href="https://www.ibm.com/support/knowledgecenter/ru/SSPFMY_1.3.5/com.ibm.scala.doc/config/iwa_cnf_scldc_apche_con_c.html" style="background: none">[↪]</a></sup>
        <!-- -->
        
        
        <footer>
Кафка изначально разрабатывалась как очередь сообщений внутри  компании линкедин.
Но переросла уже в что-то, что называют распределенной системой потоковой передачи данных, обладащей высокой пропускной способоностью, позволяющей масштабируемо собирать данные.


        </footer>
    </section> 

    



         
         
    <section class="slide">
        <h2>
            Kafka for what??
        </h2>
        
        <div class="tags-baloons">
            <span class="label">
        Messaging
            </span>
            <span class="label">
        Metrics
            </span>
            <span class="label">
        Website Activity Tracking
            </span>
            <span class="label">
        Log Aggregation
            </span>
            <span class="label">
        Stream Processing
            </span>
            <span class="label">
        Event Sourcing
            </span>
            <span class="label">
        Commit Log
            </span>
        </div>
        <div class="tags-baloons">
            <span class="label">
        Queue
            </span>
        </div>
        
        
        <footer>
Для чего кафку используют?
Для сбора и передачи сообщений. В том числе каких-то метрик, каких-то действий пользователя на сайте.
Можно использовать для сбора логов приложений. 
Да много для чего можно использовать.
В том числе и для построения очередей.



В принципе, что-то из этого можно делать и с использованием других технологий...
        </footer>
    </section>
    

    
    <section class="slide">
        <h2>
            Why Kafka???
        </h2>
        <div class="tags-baloons">
            <span class="label">
                up to 2,000,000 messages per sec
            </span>
            <br>
            or even more...
        <sup><a href="https://engineering.linkedin.com/kafka/benchmarking-apache-kafka-2-million-writes-second-three-cheap-machines" style="background: none">[↪]</a></sup>
        </div>  
        
        
        <footer>
Но кафка нас зацепила вот такими цифрами.
Конечно, это синтетические бенчмарки, но цифры-то впечатляют!

        </footer>   
    </section> 


    <section class="slide">
        <h2>
            Alternatives for Kafka
        </h2>
        <div class="tags-baloons">
            <span class="label">
                RabbitMQ
            </span>
            <span class="label">
                ActiveMQ
            </span>
            
            <br>
            
            <span class="label">
                NATS
            </span>
            <span class="label">
               Apache Pulsar
            </span>
            <span class="label">
                NSQ
            </span>
            <br>
            <span class="label">
                AWS Kinesis
            </span>
        </div>     
        
        
        <footer>
А есть ли вообще хорошие альтернативы Кафке?
Зачастую приводят вот такие интрументы.

Рэбит и Актив MQ не могут похвастаться такими цифрами в плане производителности, да и с масштабированием у них чуть похуже.

А вот эта тройка, NATS, Pulsar, NSQ, вполне себе хвалится цифрами в бенчмарках. Где-то даже эти цифры поинтереснее.
Но нужно же еще смотреть и на популярность технологии. На поддержку со стороны сообщества и различных вендоров. Сейчас Кафка выигрывает в этом плане.

Ну и Kinesis. Если вы хотите привязать себя намертво к амазону, то почему бы и нет. Тем более у кинезиса есть много интересных штук...
Но если вы хотите чувствовать себя посвободнее, то амазон с недавних пор предоставляет Кафку как сервис. Дороговато чуть-чуть, но убирает головную боль по администрированию кластера в какой-то степени.

        </footer>
    </section> 
         
    


    <section class="slide">
        <h2>Kafka: Overview</h2>
        <img src="../kafka-mogilev/pictures/kafka-architecture-topics-producers-consumers.svg" alt="" class="cover w hotfix">  
        <span class="slide-footer" style="font-size:12px">
        see some details on <a href="https://dzone.com/articles/kafka-architecture">dzone.com</a>
        </span>
        
        
        <footer>

Посмотрим, как работать с кафкой, на хайлевеле, так сказать.
У нас есть кластер кафки и внутри этого кластера есть топики, своего рода именованные очереди.
И есть продьюсеры с консумерами.
Продьюсеры, производители, производят запись каких-то сообщений в выбранный топик.
А консумеры, потребители, забирают записанные данные из тех топиков, на которые они подписаны.
        </footer>
    </section>
    
    

    <section class="slide">
        <h2>Kafka: Partitions for Topics</h2>
        <img src="../kafka-mogilev/pictures/kafka-partitioning-0.png" alt="" class="cover h" style="margin-top: -30px">  
        <span class="slide-footer">
        Fig. from <a href="https://stackoverflow.com/questions/38024514/understanding-kafka-topics-and-partitions">mrsrinivas
</a>
        </span>
        
        
        <footer>
Топик внутри себя может содержать несколько партиций. Разбиение топика на партиции позволяет сильно повышать производительность записи. Т.к. партиции одного топика могут храниться как на разных дисках одной машины, так и вовсе на разных машинах.
Размер топика, размер партиций, теоретически ничем не ограничены, разве что размером диска. И временем жизни сообщения, которое вы можете также изменить.

        </footer>
    </section>
    
    <!--
    <section class="slide">
        <h2>Kafka: Partitions (m Partitions&gt; n Consumers)</h2>
        <img src="../kafka-mogilev/pictures/kafka-partitioning-1-few-consumers.png" alt="" class="cover h" style="margin-top: -30px">  
        <span class="slide-footer">
        Fig. from <a href="https://stackoverflow.com/questions/38024514/understanding-kafka-topics-and-partitions">mrsrinivas
</a>
        </span>
    </section>
    <section class="slide">
        <h2>Kafka: Partitions (m Partitions == n Consumers)</h2>
        <img src="../kafka-mogilev/pictures/kafka-partitioning-2-one-to-one-consumers.png" alt="" class="cover h" style="margin-top: -30px">  
        <span class="slide-footer">
        Fig. from <a href="https://stackoverflow.com/questions/38024514/understanding-kafka-topics-and-partitions">mrsrinivas
</a>
        </span>
    </section>
    <section class="slide">
        <h2>Kafka: Partitions (m Partinios&lt; n Consumers)</h2>
        <img src="../kafka-mogilev/pictures/kafka-partitioning-3-too-many-consumers.png" alt="" class="cover h" style="margin-top: -30px">  
        <span class="slide-footer">
        Fig. from <a href="https://stackoverflow.com/questions/38024514/understanding-kafka-topics-and-partitions">mrsrinivas
</a>
        </span>
    </section><!-- -->
    <section class="slide">
        <h2>Kafka: Partitions: few consumer groups</h2>
        <img src="../kafka-mogilev/pictures/kafka-partitioning-4-few-groups-of-consumers.png" alt="" class="cover h" style="margin-top: -30px">  
        <span class="slide-footer">
        derivative of the fig. from <a href="https://stackoverflow.com/questions/38024514/understanding-kafka-topics-and-partitions">mrsrinivas
</a>
        </span>
        
        
        <footer>

И так у нас есть топик, разбитый на четыре раздела.
И есть две группы потребителей. Каждому консумеру в группе какфка назначает набор партиций, который он будет обрабатывать, от одного до нескольких. Зависит от количества партиций и от количества консумеров в группе. Однако, есть принципиальное ограничение, одна партиция не может обрабатываться сразу двумя консумерами из ОДНОЙ группы. Как видите, пятый консумер первой группы простаивает.

Но группы потребителей работают независимо. Сообщения из топика после обработки не удаляются, поэтому вторая группа может обработать те же сообщения, но уже со своей логикой обработки.

        </footer>
    </section>
    




    <section class="slide">
        <h2>Kafka: Consumers Offsets Example for 1 Partition</h2>
            <pre class="plain"><code style="line-height: 1!important">


          ┌───[Consumer Group 1]
          │<span style="color:darkred">
1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18</span>
    │
    └───[Consumer Group 2]
            </code></pre>
        
        
        <footer>
Для понимания того, какие сообщения какой группе консумеров отдавать используется концепция офсетов.
Давайте посмотрим на примере топика, у которого только одна партиция.
Первая группа обработала 5 сообщений и работает над шестым. Сообщения из топика не удаляются после обработки.
Вторая группа работает помедленнее, обработала два сообщения, трудится над третьим.

        </footer>
    </section>


    <section class="slide">
        <h2>Kafka: Consumers Offsets Example for 1 Partition</h2>
            <pre class="plain"><code style="line-height: 1!important">


                  ┌───[Consumer Group 1]
                  │<span style="color:darkred">
1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|<mark>19|20</mark></span>
      │
      └───[Consumer Group 2]
            </code></pre>
        
        
        <footer>
Продьюсеры накидали в ощередь пару новых сообщений.
Группы  консумеров продолжают трудиться со своей скоростью, обрабатывая сообщения и сообщая кафке, что сообщения ими обработаны. Т.е. они "коммитают" оффсет по мере обработки сообщений.

        </footer>
    </section>


    <section class="slide">
        <h2>Kafka: Consumers Offsets Example for 1 Partition</h2>
            <pre class="plain"><code style="line-height: 1!important">


                           ┌───[Consumer Group 1]
                           │<span style="color:darkred">
1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|<mark>21|22|23</mark></span>
│           │
│           └───[Consumer Group 2]
│
└───[Consumer Group 3]
            </code></pre>
        
        
        <footer>
пришла еще одна группа потребителей и начала обрабатывать топик с самого начала
А продьюсеры подкидывают все работки.
Все сообщения идут строго одно-за другим. Порядок гарантирован: все сообщения будут обработаны одно за другим консумерами.


        </footer>
    </section>


    <section class="slide">
        <h2>Kafka: Consumers Offsets Example for 1 Partition</h2>
            <pre class="plain"><code style="line-height: 1!important">
                                    [Consumer Group 4]───┐
                                                         │
                           ┌───[Consumer Group 1]        │ 
                           │                             │<span style="color:darkred">
1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23</span>
│           │
│           └───[Consumer Group 2]
│
└───[Consumer Group 3]
            </code></pre>
        
        
        <footer>

А вот пришла четвертая группа и решила "да в гробу я видала эти старые сообщения, начну с актуальных". И так тоже можно.

        </footer>
    </section>
    


    <section class="slide">
        <h2>Kafka: Reset Consumer Group Offsets tooling</h2>
            <pre class="plain" style="margin-top: -2rem"><code >
  Reset to Datetime 
  Reset from Duration
  Reset to Earliest
  Reset to Latest
  Reset to Current Time
  Reset to Offset
  Shift Offset by 'n' 
  Reset from file

            </code></pre>
        
        
        <footer>
Есть различные способы управления оффсетом. Консьюмер может начать как с начала очереди, так и с конца. Или "отмотать" оффсет на произвольную дату, или на несколько позиций вперед\назад.
Очень гибко все

        </footer>
    </section>


    <section class="slide">
        <h2>Kafka: Consumers Offsets Example for <span style="color:firebrick">3</span> Partitions</h2>
        <style>
          .custom-sup-indexes  {
            color: lightseagreen!important;
          }
          .custom-sup-indexes sup {
            color: black!important;
          }
        </style>
            <pre class="plain custom-sup-indexes"><code style="line-height: 1!important; margin-top: -1.5em">
                        ┌───[<mark>CG</mark> 1 <span class="label">C</span> 1] 
                        │ <span style="color:darkred">
Partition 1 >> 1<sup>1</sup>|4<sup>2</sup>|7<sup>3</sup>|10<sup>4</sup>|13<sup>5</sup>|16<sup>6</sup>|19<sup>7</sup>|22<sup>8</sup>|25<sup>9</sup></span>
                     │
                     └───[<mark>CG</mark> 2 <span class="label">C</span> 1]

                  ┌───[<mark>CG</mark> 1 <span class="label">C</span> 2] 
                  │ <span style="color:darkblue">
Partition 2 >> 2<sup>1</sup>|5<sup>2</sup>|8<sup>3</sup>|11<sup>4</sup>|14<sup>5</sup>|17<sup>6</sup>|20<sup>7</sup>|23<sup>8</sup></span>
                  │
                  └───[<mark>CG</mark> 2 <span class="label">C</span> 2]

                            ┌───[<mark>CG</mark> 1 <span class="label">C</span> 3] 
                            │ <span style="color:purple">
Partition 3 >> 3<sup>1</sup>|6<sup>2</sup>|9<sup>3</sup>|12<sup>4</sup>|15<sup>5</sup>|18<sup>6</sup>|21<sup>7</sup>|24<sup>8</sup></span>
               │
               └───[<mark>CG</mark> 2 <span class="label">C</span> 3]
 
            </code></pre>

        <span class="slide-footer" style="font-size: 16px; padding: 10px 0px; text-align: left; opacity: 0.6">
            legend:
            <br><br>
            <mark>CG</mark> — Consumers Group
            <br>
            <span class="label">C</span> — Consumer (in group)
        </span>
        
        
        <footer>

С одной партицией было попроще, а если их три?
Тогда сообщения, приходящие от продьюсеров, будут по какой-то логике распределяться по трем партициям.
У нас уже не будет четкой гарантии того, что все сообщения в рамках топика идут один за одним, ровно в том порядке, как они пришли в кафку. И хоть эта гарантия все еще есть на уровне партиции, мы не можем гарантировать, что консумеры одной группы будут работать с одинаковой скоростью.
Поэтому, или одна партиция на топик и строгая гарантия последовательности событий, или же скорость\производительность, но последовательность теряется.

Интересно, все же, что, кроме, скорости, дают нам партиции?

        </footer>
    </section>


    <section class="slide">
        <h2>Kafka: Overview, again :-)</h2>
        <img src="../kafka-mogilev/pictures/kafka-architecture-topics-producers-consumers.svg" alt="" class="cover w" style="margin-top: 20px">
        <span class="slide-footer" style="font-size:12px">
        see some details on <a href="https://dzone.com/articles/kafka-architecture">dzone.com</a>
        </span>
        
        
        <footer>
Давайте посмотрим еще раз.
И так, есть кластер кафки

        </footer>
    </section>

    <section class="slide">
        <h2>Kafka: Cluster</h2>
        <img src="../kafka-mogilev/pictures/kafka-architecture-cluster.svg" alt="" class="cover w" style="margin-top: 30px">  
        
        
        <footer>
Внутри кластера есть три брокера.
Это достаточно стандартная, минимальная, простейшая, конфигурация.
Три брокера в кластере. У каждого топика фактор репликации тоже выставлен в тройку. 
Таким образом каждый топик со всеми его партициями скопирован на каждый брокер.
Есть разные подходы для реплицирования: кто-то использует кворум, кто-то концепцию лидеров. Какфка использует лидеров.
Осталось понять, кто лидер.


        </footer>
    </section>

    <section class="slide">
        <h2>Kafka: Partition Leaders</h2>
        <img src="../kafka-mogilev/pictures/kafka-architecture-partition-leader.svg" alt="" class="cover w" style="margin-top: 30px">  
        
        
        <footer>

В кафке для каждой реплицированной партиции выбирается свой лидер. Лидеры распределены по разным брокерам, а не сосредоточены на одном.
        </footer>
    </section>





    <section class="slide">
        <h2>Kafka: Replication</h2>
        <img src="../kafka-mogilev/pictures/kafka-architecture-replication.svg" alt="" class="cover w" style="margin-top: 30px">  
        <span class="slide-footer">
        some details on <a href="
https://dzone.com/articles/kafka-topic-architecture-replication-failover-and">dzone.com</a>
        </span>
        
        
        <footer>
Когда продьюсер делает запись в топик, он точно знает, в какую партицию он записывает. И, соответственно, он точно знает, на каком брокере расположен лидер этой партиции.
После того, как сообщение записал лидер, оно реплицируется на всех остальные реплики.
Причем продьюсер может работать по двум разным стратегиям:
- по синхронной: он будет ждать, пока закончится реплицирования
- по асинхронной: он подождет только лидера
первая стратегия надежнее, вторая - быстрее. выбирать -- вам.

Если брокер номер 1 упадет, то кафка найдет, назначит лидеров для нулевой и второй партиции на других брокерах.
Если вы использовали асинхронную стратегию, то часть данных может быть потеряна в этом случае.

Очень за многое отвечает продьюсер. Не только за стратегию записи.
Но в том числе и за решение того, в какую конкретную партицию будет помещено сообщение. Он это может решать с помощью рандома, или же основываясь на содержимом сообщения.


        </footer>
    </section>






    <section class="slide">
        <h2>Kafka: Message structure</h2>
        <h3 class="shout">key, value<br>byte[], byte[]</h3>
        
        
        <footer>
В простейшем случае содержимое сообщения представляет из себя вот это.
Ключ, значение. И то, и другое - набор байтов.
Хоть mp3'шки туда кидайте!.
Но зачастую это все-таки какие-то структуры данных, которые надо как-то сериализовать.

        </footer>
    </section>
    
    
    
    
    
    <section class="slide">
        <h2>Kafka: Serializers</h2>
        <h3 class="shout no-bg">
            <small style="font-size: 0.5em">
                JSON, Protobuf, Thrift, <mark>Avro</mark>
            </small>
        </h3>
        
        
        <footer>
Можно использовать любые сериализаторы, конечно.
Можно хоть Pickle!
Но лучше какие-то популярные, кросс-языковые.
В мире кафки хорошо Avro прижился. Он бинарный. Со схемой. И валидацию поддерживает, и миграцию.

        </footer>
    </section>
    


    <section class="slide">
        <h2 style="border: none">Kafka: Schema overhead</h2>
        <img src="../kafka-mogilev/pictures/confluent_schema_registry-1.png" alt="" class="cover" style="margin-top: 30px">  
        <span class="slide-footer">
        Fig. from <a href="https://www.confluent.io/blog/schemas-contracts-compatibility">confluent.io</a>
        </span>
        
        <footer>
однако, есть недостаток. с каждым сообщением нужно передавать схему, чтобы можно было десериализовать. это невыгодно, даже по сравнению с json
но есть выход: держать схемы отдельно, в доступном для десиарилизатора месте.

        </footer>

    </section>




    <section class="slide">
        <h2>Kafka: Schema Registry Concept</h2>
        <img src="../kafka-mogilev/pictures/schema-registry-scheme.svg" alt="" class="cover w" style="margin-top: 20px">  
        
        
        <footer>
Такое место - реестр схем.
Самое популярное решение для кафки - от конфлуента.

        </footer>
    </section>




    <section class="slide">
        <h2>Kafka: some conclusion</h2>
        <ul>
            <li>complicated <b>a bit</b></li>
            <li><b>highly</b> scalable</li>
            <li>good performance (2,000,000 msg/sec)</li>
            <li><i>pretty good</i> availability</li>
            <li><b>not so many</b> specialists</li>
        </ul>
        <footer>
            И так, давайте подведем какой-то промежуточный вывод по кафке.
            Кафка это несколько сложноватый инструмент, в предыдущих слайдах я старался не сильно выпячивать эту сложность. Но, похоже, у меня не получилось.
            
            Но при этом Кафка хорошо масштабируется, обещает хорошую производительность и при этом надежное хранение данных и доступность этих данных.
            
            Хотя, конечно, специалистов на нашем рынке, способных с кафкой совладать, не так уж много.
            К счастью, в нашей команде такие люди были. И остальные бойцы были готовы учиться.
        </footer>
    </section>



    <section class="slide ">
        <h2 class="shout">Microservices?</h2>
        
        
        <footer>
Но давайте обратно к нашим микросервисам


        </footer>
    </section>


    <section class="slide">
        <h2>Microservices: Async Communication (Celery)</h2>
        <img src="../kafka-mogilev/pictures/2-celery-rabbit.svg" alt="" class="cover w hotfix"> 
        
        
        <footer>
Мы остановились на варианте с celery и хотим что-то изменить


        </footer> 
    </section>

    <section class="slide">
        <h2>Microservices: Async Communication (Kafka)</h2>
        <img src="../kafka-mogilev/pictures/2-kafka.svg" alt="" class="cover w hotfix"> 
        
        
        <footer>

Внедряем кафку.
Первый сервис пишет в кафку.
А дальше мы уже в других сервисах, местами, отказываемся от реста и назначаем их ответственными за реагирование на происходящие изменения в первом сервисе.
У второго и третьего сервиса появились маленькие подсервисы - кафка консумеры.
Вроде бы неплохо. 
Но можно лучше.
        </footer> 
    </section>

    <section class="slide">
        <h2>Microservices: Async. What about databases?</h2>
        <img src="../kafka-mogilev/pictures/2-kafka-detailed.svg" alt="" class="cover w hotfix">  
        
        
        <footer>
Как видно, первый сервис при своей работе что-то изменяет в своей базе данных. А потом сообщает о этих изменениях в кафку.
Двойная работа.
Может, ну ее, эту кафку? 
Зачем одни и те же данные писать два раза в два места, и поддерживать эту логику в коде сервиса?
Было бы хорошо, если бы данные сами в кафку ходили!

        </footer>
    </section>
    
    
    

    <section class="slide ">
        <h2>Relational Database → Kafka</h2>
        <img src="../kafka-mogilev/pictures/logos/debezium.svg" class="cover" style="background: black; padding: 50px; width: 70%;">
        
        
        <footer>
И так тоже можно!
Дебезиум нам это даст


        </footer>
    </section>

    <section class="slide">
        <h2>Stream data from RDBS to Kafka</h2>
        <img src="../kafka-mogilev/pictures/debezium-architecture.png" alt="" class="cover w" style="margin-top: 30px">  
        <span class="slide-footer">
        Fig. from <a href="
https://debezium.io/documentation/reference/0.9/architecture.html">debezium.io</a>
        </span>
        
        
        <footer>
Дебезиум реализует по своей сути концепт кафка-коннектора.
Вот схема с их сайта.
Элементов много.


        </footer>
    </section>


    <section class="slide">
        <h2>Stream data from PostgreSQL to Kafka</h2>
        <img src="../kafka-mogilev/pictures/debezium-architecture-part-postgre.png" alt="" class="cover w" style="margin-top: 30px">  
        <span class="slide-footer">
        Fig. from <a href="
https://debezium.io/documentation/reference/0.9/architecture.html">debezium.io</a>
        </span>
        
        
        <footer>
Нас интересуют только вот эти
Дебезиум читает лог постгреса  и транслирует изменения в кафку. 


        </footer>
    </section>




    <section class="slide">
        <h2>Microservices: Async. What about databases?</h2>
        <img src="../kafka-mogilev/pictures/2-kafka-detailed.svg" alt="" class="cover w hotfix">  
        
        
        <footer>
и теперь вот эта прошлая схема 


        </footer>
    </section>
    

    <section class="slide">
        <h2>Microservices: Async. Debezium</h2>
        <img src="../kafka-mogilev/pictures/2-kafka-debezium.svg" alt="" class="cover w hotfix">  
        
        
        <footer>
превращается вот в эту.
кода в сервисе стало меньше
дебезиум делает работу за нас.
в принципе можно было бы и со вторым сервисом и его базой что-то намутить, но пока оставим как есть.

        </footer>
    </section>


    <section class="slide">
        <h2>Microservices: Async. Debezium. Full</h2>
        <img src="../kafka-mogilev/pictures/microservices-comm-full.svg" alt="" class="cover w hotfix" style="margin-top: 130px">  
        
        
        <footer>

Итого мы пришли к вот такому решению.
Схема в виде палочек не очень понятная, да?
        </footer>
    </section>

    <section class="slide">
        <h2>Application Diagram</h2>
        <img src="../kafka-mogilev/pictures/4-ms-aws.svg" alt="" class="cover w hotfix">  
        
        
        <footer>

Давайте что-то более привычное нарисуем.
Вот на этой схеме можно заметить, что с помощью дебезиума и кафки мы полностью отвязали наше впереди-стоящее джанго приложение от остальных микросервисов.

Но а что по поводу большого потока данных из внешних источников

        </footer>
    </section>
    
    
    <section class="slide">
        <h2>Application Diagram. External Data Handling</h2>
        <img src="../kafka-mogilev/pictures/4-ms-aws-full.svg" alt="" class="cover w hotfix">  
        
        
        <footer>

Еще пара микросервисов решат эту задачу.
Забираем данные, помещаем в кафку.
Достаем из кафки, анализируем, преобразуем, кладем в базу данных основного сервиса.

Все бы хорошо, вот только слищком много Java-технологий теперь у нас в проекте. Kafka,... Debezium...
        </footer>
    </section>



    <section class="slide ">
        <h2>some conclusions about kafka+microservices</h2>
        <h2 class="shout">?</h2>
    </section>




    

    <section class="slide black">
        <h2 class="shout">What about Python?</h2>  
    </section>
    
    
    <section class="slide ">
        <div class="tags-baloons ">
            <span class="label">
                kafka-python
            </span>
            <span class="label">
                pykafka
            </span>
            <span class="label">
                confluent-kafka-python
            </span>
            
            <span class="label">
                aiokafka
            </span>
            
        </div>  
        <!-- сравнение (2016 год) http://activisiongamescience.github.io/2016/06/15/Kafka-Client-Benchmarking/ -->
        <!-- сравнение (2017 год) http://matthewrocklin.com/blog/work/2017/10/10/kafka-python -->
        <!-- еще одно сравнение, без таблиц (2017 год) https://blog.datasyndrome.com/a-tale-of-two-kafka-clients-c613efab49df -->
        <!-- код для бенчмаркинга: https://github.com/sucitw/benchmark-python-client-for-kafka -->
        <!-- ^ доклад по этому бенчмарку и общий рассказ про Кафку https://speakerdeck.com/sucitw/connect-k-of-smack-pykafka-kafka-python-or?slide=25 -->  
    </section>
    
    <section class="slide ">
        <h2>What to choose?</h2>
        <table>
            <tr>
                <td></td>
                <td>kafka-python</td>
                <td>pykafka</td>
                <td>confluent-kafka</td>
            </tr>
            <tr>
                <td>Stars</td>
                <td>~ 3 400</td>
                <td>~ 1 000</td>
                <td>~ 1 500</td>
            </tr>
            <tr>
                <td>Contributors*</td>
                <td>0 / 4 / 13 / 186</td>
                <td>1 / 5 / 10 / 77</td>
                <td>0 / 1 / 6 / 57</td>
            </tr>
            <tr>
                <td>Releases track</td>
                <td>fine</td>
                <td>hm… <sup>(2018???)</sup></td>
                <td>fine</td>
            </tr>
            <tr>
                <td>Development track</td>
                <td>fine</td>
                <td>hm…</td>
                <td>fine</td>
            </tr>
        </table>
    
        <span class="slide-footer" style="font-size: 16px; padding: 10px 0px; text-align: left; opacity: 0.6">
            <code>*<br>
            a / b / c / d<br>
            a — more 1k commits<br>
            100 ≤ b &lt; 1000<br>
             10 ≤ c &lt; 100<br>
            d — all commits</code>
        </span>
    
    </section>


    <section class="slide ">
        <h2>What about Throughput?</h2>
        <!-- PRODUCER -->
        <style>
        
        .slide table.striped tr:nth-child(even) { background: rgba(64, 64, 64, .35) }
        .special-throughput tr td:last-child, .special-throughput td {
             text-align: right ;
                 font-family: PT Mono, monospace;

             }
         .special-throughput .a-right { text-align: right; }
         .special-throughput .very-good { background: rgba(32, 64, 96, .15) }
        </style>
        <table class=" special-throughput" style="margin-top: -10px; font-size: 22px">
              <thead>
                <tr style="text-align: right;">
                  <th></th>
                  <th></th>
                  <th class="a-right">time (seconds)</th>
                  <th class="a-right">MBs/s</th>
                  <th class="a-right">Msgs/s</th>
                </tr>
              </thead>
              <tbody>
                <tr class="very-good">
                  <th>producer</th>
                  <th>confluent_kafka_producer</th>
                  <td>5.4</td>
                  <td>17</td>
                  <td>183 000</td>
                </tr>
                <tr>
                  <th>producer</th>
                  <th>pykafka_producer_rdkafka</th>
                  <td>16</td>
                  <td>6.1</td>
                  <td>64 000</td>
                </tr>
                <tr>
                  <th>producer</th>
                  <th>pykafka_producer</th>
                  <td>57</td>
                  <td>1.7</td>
                  <td>17 000</td>
                </tr>
                <tr>
                  <th>producer</th>
                  <th>python_kafka_producer</th>
                  <td>68</td>
                  <td>1.4</td>
                  <td>15 000</td>
                </tr>
                <!-- CONSUMER -->
                <tr class="very-good">
                  <th>consumer</th>
                  <th>confluent_kafka_producer</th>
                  <td>5.4</td>
                  <td>17</td>
                  <td>183 000</td>
                </tr>
                <tr>
                  <th>consumer</th>
                  <th>pykafka_producer_rdkafka</th>
                  <td>16</td>
                  <td>6.1</td>
                  <td>64 000</td>
                </tr>
                <tr>
                  <th>consumer</th>
                  <th>pykafka_producer</th>
                  <td>57</td>
                  <td>1.7</td>
                  <td>17 000</td>
                </tr>
                <tr>
                  <th>consumer</th>
                  <th>python_kafka_producer</th>
                  <td>68</td>
                  <td>1.4</td>
                  <td>15 000</td>
                </tr>
              </tbody>
            </table>
        </table>
        
        <div class="slide-footer">
            benchmarking by <a href="http://matthewrocklin.com/blog/work/2017/10/10/kafka-python">Matthew Rocklin</a>
        </div>
 
    </section>
    
    
    
    <section class="slide">
        <h2>Kafka Producer on Python</h2>
        <pre><code style="margin-top: -2rem; line-height: 1; font-size:20px">
from confluent_kafka import Producer
import sys
if __name__ == '__main__':
    broker = sys.argv[1]
    topic = sys.argv[2]
        
    producer = Producer(**{'bootstrap.servers': broker})
    delivery_callback = lambda err, msg: print(err or msg)

    for something in range(1000):
        try:
            producer.produce(topic, str(something),
                      callback=delivery_callback)
        except BufferError:
            print("Local producer queue is full, try again")
        # Serve delivery callback queue.
        producer.poll(0)
        # Wait until all messages have been delivered
        producer.flush()
    </code></pre>
        
    </section>



    <section class="slide">
        <h2>Kafka Consumer on Python</h2>
        <pre><code style="margin-top: -2rem; line-height: 1; font-size:20px">
from confluent_kafka import Consumer, KafkaException
import sys
if __name__ == '__main__':
    broker, group, topics = sys.argv[1], sys.argv[2], sys.argv[3:]
    conf = {'bootstrap.servers': broker, 'group.id': group,
            'auto.offset.reset': 'earliest'}
    clb = lambda consumer, p: print('Assigned partition:', p)

    consumer = Consumer(conf)
    consumer.subscribe(topics, on_assign=clb)
    try:
        while True:
            msg = c.poll(timeout=1.0)
            if msg is None:
                continue
            if msg.error():
                raise KafkaException(msg.error())
            else:
                print(msg.topic(), msg.partition(), msg.offset(),
                      msg.key(), msg.value())
    finally:
        consumer.close() # ... to commit final offsets.
            
        </code></pre>
        
    </section>
    















    <section class="slide ">
        <h2 class="shout">Conclusion?</h2>
    </section>
    
    
    
    


    <section class="slide ">
        <h2 class="shout">Thanks!</h2>
        </div>    
        
        
        <footer>
Спасибо за внимание


        </footer>
    </section>
    
    
    <section class="slide ">
        <h2 class="shout">Questions?</h2>
        </div>    
        
        
        <footer>
Буду рад вашим вопросам.


        </footer>
    </section>



    <div class="progress"></div>

    <footer class="badge">
        <a href="https://github.com/shurph/talks">Fork me on GitHub!</a>
    </footer>

    <script src="../vendor/shower/scripts/shower.min.js"></script>

    <script src="../vendor/shower/vendors/highlight/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</body>

</html>

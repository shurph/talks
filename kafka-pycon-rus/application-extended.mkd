План выступления:
1. почему нам понадобилась Kafka в приложении:
  1) большой поток данных, который:
    1] нужно обрабатывать надёжно
    2] нужно обрабатывать оперативно
    3] может увеличиться вскоре и нужно быть к этому готовыми
  2) необходимость как-то общаться микросервисам между собой
  3) kafka уже достаточно устоявшийся продукт, который в т.ч. можно получить как «SaaS» (AWS MSK)
2. Краткое введение, что такое Kafka
  1) Основные "киты" Kafk'и:
    1] распределённость,
    2] масштабируемость,
    3] отказоустойчивость
  2) Основные "концепции":
    1] продьюсеры и консумеры
    2] топики и партиции
    3] брокеры Кафки и координаторы/менеджеры брокеров в лице Zookeeper
  3) Почему Кафка так быстра
3. Python библиотеки для работы с Kafka
  1) python-kafka
  2) pykafka
  3) aiokafka
  4) confluent-kafka
4. Каким способом мы используем Kafka
  1) Общий вид архитектуры проекта
    - "воркеры", собирающие внешние данные из HTTP (REST) / AMQP (Rabbit) источников в "промежуточные" топики Кафки в "сыром" виде
    - сервисы, обрабатывающие сырые данные из промежуточных топиков и перекладывающие обработанные, структурированные данные в основные топики
    - сервисы, "обогащающие" полученные данные дополнительной информацией на основе других внешних источников
    - "потоковое" (создание сущностей, обновление состояния) взаимодействие между остальными микросервисами также происходит через отдельные топики
  2) Схема данных: нужна ли? Если нужна, то:
    - В каком формате она должна быть? (JSON, Avro, ещё что-то?)
    - Где схема должна храниться? (Непосредственно в сообщении? Отдельный сервис схем?)
    - Наш подход: часть данных — вообще без схемы, часть — со схемой в Avro, "вшитой" в сообщение (с заделом/задумкой перейти в дальнейшем на отдельный сервис для хранения схем)
  3) Проблемы дальнейшего роста, масштабирования:
    - сколько топиков нам нужно для работы приложения?
    - сколько партишенов и консюмеров нам нужно, учитывая возможные накладные расходы при их увеличении
    - нужно ли держать отдельный "контрольный канал" для контроля гарантированной доставки сообщений


